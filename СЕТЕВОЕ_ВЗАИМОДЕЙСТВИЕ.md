# Сетевое взаимодействие в игре "Гонка в лабиринте"

## Архитектура

Игра использует архитектуру **Client-Server** с одним сервером и одним клиентом.

```
┌─────────────┐         ┌─────────────┐
│   Сервер    │◄────────►│   Клиент    │
│  (Игрок 1)  │  Socket  │  (Игрок 2)  │
└─────────────┘          └─────────────┘
```

## Компоненты сетевого взаимодействия

### 1. GameServer (Сервер)
- **Назначение**: Управляет игрой, обрабатывает логику, хранит состояние
- **Порт**: 12345 (по умолчанию)
- **Игрок**: Игрок 1 (ID = 1)

### 2. GameClient (Клиент)
- **Назначение**: Подключается к серверу, отправляет команды, получает обновления
- **Игрок**: Игрок 2 (ID = 2)

### 3. ClientHandler (Обработчик клиента)
- **Назначение**: Отдельный поток для каждого клиента на сервере
- **Функции**: Принимает сообщения от клиента, отправляет ответы

### 4. Протокол
- **Message**: Объект сообщения
- **MessageType**: Типы сообщений
- **ProtocolParser**: Парсер протокола (отправка/получение)

## Протокол передачи данных

### Формат сообщений

Все сообщения передаются в текстовом формате с разделителем `|`:

```
ТИП|данные1|данные2|данные3\n
```

### Типы сообщений

#### 1. GAME_START
**Назначение**: Начало игры, инициализация клиента

**Формат**: `GAME_START|playerId|mazeSeed|startX|startY|exitX|exitY`

**Пример**: `GAME_START|2|1234567890|39|49|20|25`

**Отправляет**: Сервер → Клиент

**Когда**: При подключении клиента и инициализации игры

---

#### 2. PLAYER_MOVE
**Назначение**: Запрос на движение игрока

**Формат**: `PLAYER_MOVE|playerId|direction`

**Пример**: `PLAYER_MOVE|2|ВПРАВО`

**Отправляет**: Клиент → Сервер

**Когда**: Игрок нажимает клавишу движения

---

#### 3. PLAYER_POSITION
**Назначение**: Обновление позиции игрока

**Формат**: `PLAYER_POSITION|playerId|x|y|direction`

**Пример**: `PLAYER_POSITION|1|5|10|ВНИЗ`

**Отправляет**: Сервер → Клиент

**Когда**: После успешного движения игрока

---

#### 4. GAME_END
**Назначение**: Окончание игры

**Формат**: `GAME_END|winnerId|time`

**Пример**: `GAME_END|1|15000`

**Отправляет**: Сервер → Клиент

**Когда**: Когда один из игроков достигает финиша

---

#### 5. SYNC_REQUEST
**Назначение**: Запрос синхронизации состояния

**Формат**: `SYNC_REQUEST|playerId`

**Пример**: `SYNC_REQUEST|2`

**Отправляет**: Клиент → Сервер

**Когда**: Клиент хочет получить актуальное состояние игры

## Процесс подключения

### Шаг 1: Запуск сервера

```java
GameServer server = new GameServer(12345);
server.addServerPlayer();  // Создаем игрока 1
server.start();            // Запускаем сервер
```

**Что происходит**:
1. Создается `ServerSocket` на порту 12345
2. Сервер ждет подключения клиента (`serverSocket.accept()`)
3. Создается `GameState` для игрока 1

### Шаг 2: Подключение клиента

```java
GameClient client = new GameClient("localhost", 12345, listener);
client.start();  // Подключается к серверу
```

**Что происходит**:
1. Клиент создает `Socket` и подключается к серверу
2. Сервер принимает соединение
3. Создается `ClientHandler` для обработки этого клиента
4. `ClientHandler` запускается в отдельном потоке

### Шаг 3: Инициализация игры

```java
// На сервере
initializeGame() {
    - Создает лабиринт с seed
    - Устанавливает позиции игроков
    - Отправляет GAME_START клиенту
}
```

**Что происходит**:
1. Сервер создает лабиринт с уникальным `seed`
2. Игрок 1: позиция (0, 0)
3. Игрок 2: позиция (39, 49)
4. Финиш: центр лабиринта (20, 25)
5. Сервер отправляет `GAME_START` клиенту с seed и позициями

### Шаг 4: Синхронизация лабиринта

```java
// На клиенте
handleGameStart() {
    - Получает seed от сервера
    - Создает лабиринт с тем же seed
    - Инициализирует GameState
}
```

**Важно**: Одинаковый `seed` гарантирует одинаковый лабиринт на сервере и клиенте!

## Процесс игры

### Движение игрока (Клиент)

```
1. Игрок нажимает клавишу (стрелка/WASD)
   ↓
2. GameWindow.handleMove()
   ↓
3. GameClient.sendMove("ВПРАВО")
   ↓
4. Создается сообщение PLAYER_MOVE|2|ВПРАВО
   ↓
5. Отправляется на сервер через Socket
```

### Обработка движения (Сервер)

```
1. ClientHandler получает PLAYER_MOVE
   ↓
2. handlePlayerMove() проверяет:
   - Правильный ли playerId?
   - Игрок не финишировал?
   - Можно ли двигаться? (maze.canMove())
   ↓
3. Если да:
   - Обновляет позицию в GameState
   - Проверяет победу (checkWin())
   - Рассылает обновление всем (broadcastPosition())
```

### Рассылка обновлений

```java
server.broadcastPosition(playerId, x, y, direction) {
    1. Обновляет GameState на сервере
    2. Отправляет PLAYER_POSITION всем клиентам
    3. Серверное окно обновляется локально
}
```

### Получение обновлений (Клиент)

```
1. GameClient получает PLAYER_POSITION
   ↓
2. handlePositionUpdate()
   ↓
3. Обновляет позицию игрока в GameState
   ↓
4. Вызывает listener.onPositionUpdate()
   ↓
5. GameWindow обновляет UI (repaint())
```

## Окончание игры

### Когда игрок достигает финиша

```
1. checkWin() возвращает true
   ↓
2. endGame() помечает игру как завершенную
   ↓
3. broadcastGameEnd() рассылает GAME_END:
   ├─ Серверному окну (через GameEndListener)
   └─ Клиенту (через ClientHandler.sendGameEnd())
   ↓
4. Оба окна получают уведомление
   ↓
5. Показывают победителя и останавливают таймер
```

## Потоки и синхронизация

### Потоки на сервере

1. **Главный поток**: UI (GameWindow)
2. **Поток сервера**: Ожидание подключений
3. **ClientHandler поток**: Обработка каждого клиента

### Потоки на клиенте

1. **Главный поток**: UI (GameWindow)
2. **GameClient поток**: Получение сообщений от сервера

### Синхронизация UI

```java
// Все обновления UI выполняются в EDT
SwingUtilities.invokeLater(() -> {
    gamePanel.repaint();
    compassPanel.repaint();
});
```

## Технические детали

### Сокеты

- **ServerSocket**: Слушает входящие подключения
- **Socket**: Двусторонняя связь между сервером и клиентом

### Потоки ввода/вывода

- **PrintWriter**: Отправка текстовых данных
- **BufferedReader**: Получение текстовых данных
- **Автоматический flush**: `PrintWriter(..., true)` автоматически сбрасывает буфер

### Обработка ошибок

- Все сетевые операции обернуты в `try-catch`
- При разрыве соединения потоки корректно закрываются
- UI уведомляется об ошибках

## Схема полного цикла игры

```
┌─────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ                        │
├─────────────────────────────────────────────────────────┤
│ 1. Сервер запускается, ждет клиента                     │
│ 2. Клиент подключается                                  │
│ 3. Сервер создает лабиринт с seed                       │
│ 4. Сервер отправляет GAME_START клиенту                  │
│ 5. Клиент создает лабиринт с тем же seed                │
│ 6. Оба игрока готовы к игре                             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                      ИГРОВОЙ ЦИКЛ                       │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  КЛИЕНТ:                                                 │
│  ┌──────────────────────────────────────┐               │
│  │ Игрок нажимает клавишу               │               │
│  │ → sendMove("ВПРАВО")                 │               │
│  │ → PLAYER_MOVE|2|ВПРАВО              │               │
│  └──────────────────────────────────────┘               │
│                    ↓                                     │
│  СЕРВЕР:                                                 │
│  ┌──────────────────────────────────────┐               │
│  │ Получает PLAYER_MOVE                  │               │
│  │ → Проверяет canMove()                │               │
│  │ → Обновляет позицию                  │               │
│  │ → Проверяет победу                   │               │
│  │ → broadcastPosition()                │               │
│  └──────────────────────────────────────┘               │
│                    ↓                                     │
│  РАССЫЛКА:                                               │
│  ┌──────────────────────────────────────┐               │
│  │ → Серверному окну (локально)         │               │
│  │ → Клиенту (PLAYER_POSITION)          │               │
│  └──────────────────────────────────────┘               │
│                    ↓                                     │
│  ОБНОВЛЕНИЕ UI:                                          │
│  ┌──────────────────────────────────────┐               │
│  │ Оба окна получают обновление          │               │
│  │ → Обновляют GameState                 │               │
│  │ → repaint() панелей                   │               │
│  └──────────────────────────────────────┘               │
│                                                          │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    ОКОНЧАНИЕ ИГРЫ                       │
├─────────────────────────────────────────────────────────┤
│ 1. Игрок достигает финиша                                │
│ 2. checkWin() возвращает true                            │
│ 3. broadcastGameEnd() рассылает GAME_END                │
│ 4. Оба окна показывают победителя                       │
│ 5. Таймер останавливается                               │
└─────────────────────────────────────────────────────────┘
```

## Важные особенности

### 1. Детерминированность лабиринта
- Одинаковый `seed` = одинаковый генератор = одинаковый лабиринт
- Гарантирует синхронизацию между сервером и клиентом

### 2. Авторизация
- Каждый `ClientHandler` проверяет `playerId` в сообщениях
- Предотвращает подмену игрока

### 3. Валидация на сервере
- Все движения проверяются на сервере
- Клиент не может "читерить" - сервер проверяет `canMove()`

### 4. Единый источник истины
- `GameState` на сервере - это источник истины
- Клиент получает обновления, но не управляет логикой

### 5. Потокобезопасность
- Каждый клиент обрабатывается в отдельном потоке
- UI обновляется через `SwingUtilities.invokeLater()`

## Примеры сообщений

### Начало игры
```
Сервер → Клиент:
GAME_START|2|1725123456789|39|49|20|25
```

### Движение
```
Клиент → Сервер:
PLAYER_MOVE|2|ВПРАВО

Сервер → Клиент:
PLAYER_POSITION|2|40|49|ВПРАВО
```

### Окончание игры
```
Сервер → Клиент:
GAME_END|1|15234
```

## Заключение

Сетевое взаимодействие построено на простом текстовом протоколе через Java Sockets. Сервер является авторитетным источником состояния игры, клиент отправляет команды и получает обновления. Все движения валидируются на сервере, что обеспечивает честность игры.


