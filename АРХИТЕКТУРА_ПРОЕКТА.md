# Архитектура проекта "Гонка в лабиринте"

## Содержание

1. [Общая архитектура](#общая-архитектура)
2. [Сетевые классы](#сетевые-классы)
3. [Протокол](#протокол)
4. [Модель данных](#модель-данных)
5. [Генерация лабиринта](#генерация-лабиринта)
6. [UI компоненты](#ui-компоненты)
7. [Утилиты](#утилиты)

---

## Общая архитектура

Проект использует архитектуру **Client-Server** с разделением на слои:

```
┌─────────────────────────────────────────┐
│           UI Layer (Swing)              │
│  GameWindow, GamePanel, CompassPanel    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│        Network Layer (Sockets)           │
│  GameServer, GameClient, ClientHandler   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│         Protocol Layer                   │
│  Message, MessageType, ProtocolParser    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│         Model Layer                      │
│  GameState, Player, Maze, Generators     │
└─────────────────────────────────────────┘
```

---

## Сетевые классы

### GameServer

**Пакет**: `game.server`  
**Назначение**: Центральный сервер, управляющий игрой

#### Основные поля:

```java
private ServerSocket serverSocket;      // Сокет для приема подключений
private List<ClientHandler> clients;   // Список подключенных клиентов
private GameState gameState;            // Состояние игры (источник истины)
private boolean gameInitialized;       // Флаг инициализации игры
private GameEndListener gameEndListener; // Callback для уведомления UI
```

#### Ключевые методы:

##### `GameServer(int port)`
- Создает `ServerSocket` на указанном порту
- Инициализирует список клиентов
- Выводит сообщение о запуске

##### `start()`
**Процесс запуска сервера:**
1. Вызывает `waitForServerPlayer()` - ожидает готовности серверного игрока
2. Вызывает `waitForClient()` - ждет подключения клиента через `serverSocket.accept()`
3. Вызывает `initializeGame()` - инициализирует игру когда оба игрока готовы

**Важно**: `accept()` блокирует поток до подключения клиента

##### `waitForClient()`
```java
Socket clientSocket = serverSocket.accept();  // Блокирующий вызов
ClientHandler clientHandler = new ClientHandler(clientSocket, this, 2);
clients.add(clientHandler);
clientHandler.start();  // Запускает поток обработки клиента
```

**Что происходит:**
- Сервер ждет подключения (блокируется)
- При подключении создается `ClientHandler` с `playerId = 2`
- `ClientHandler` запускается в отдельном потоке
- Клиент добавляется в список для рассылки сообщений

##### `initializeGame()`
**Критический метод инициализации:**

```java
// 1. Создает лабиринт с seed
long seed = System.currentTimeMillis();
Maze maze = new Maze(Constants.MAZE_WIDTH, Constants.MAZE_HEIGHT, seed);

// 2. Устанавливает позиции игроков
player1.setPosition(0, 0);                    // Игрок 1 (сервер)
player2.setPosition(39, 49);                  // Игрок 2 (клиент)

// 3. Определяет финиш
int[] exitPos = maze.getFixedExitPosition(); // Центр лабиринта

// 4. Инициализирует GameState
gameState.initialize(maze, exitX, exitY);

// 5. Рассылает GAME_START всем клиентам
for (ClientHandler client : clients) {
    client.sendGameStart();
}
```

**Важно**: Seed передается клиенту для синхронизации лабиринта!

##### `broadcastPosition(int playerId, int x, int y, String direction)`
**Рассылка обновлений позиции:**

```java
// 1. Обновляет GameState на сервере (источник истины)
player.setPosition(x, y);
player.setDirection(direction);

// 2. Рассылает всем клиентам
for (ClientHandler client : clients) {
    client.sendPositionUpdate(playerId, x, y, direction);
}
```

**Особенность**: Серверное окно обновляется локально, клиент получает сообщение

##### `broadcastGameEnd(int winnerId, long time)`
**Рассылка окончания игры:**

```java
// 1. Уведомляет серверное окно через callback
if (gameEndListener != null) {
    gameEndListener.onGameEnd(winnerId, time);
}

// 2. Рассылает клиентам
for (ClientHandler client : clients) {
    client.sendGameEnd(winnerId, time);
}
```

**Паттерн**: Использует Listener для уведомления UI без прямой зависимости

#### Потоки:

- **Главный поток**: UI (GameWindow)
- **Поток сервера**: Ожидание подключений (может быть в отдельном потоке)
- **ClientHandler потоки**: По одному на каждого клиента

---

### ClientHandler

**Пакет**: `game.server`  
**Наследует**: `Thread`  
**Назначение**: Обработчик одного клиента на сервере

#### Основные поля:

```java
private Socket socket;           // Сокет соединения с клиентом
private GameServer server;        // Ссылка на сервер
private PrintWriter out;          // Поток отправки данных
private BufferedReader in;        // Поток получения данных
private int playerId;             // ID игрока (всегда 2 для клиента)
private boolean running;          // Флаг работы потока
```

#### Ключевые методы:

##### `ClientHandler(Socket socket, GameServer server, int playerId)`
**Инициализация соединения:**

```java
// Создает потоки ввода/вывода
out = new PrintWriter(socket.getOutputStream(), true);  // auto-flush
in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
```

**Важно**: `PrintWriter(..., true)` автоматически сбрасывает буфер после каждого вызова

##### `run()`
**Главный цикл обработки клиента:**

```java
public void run() {
    try {
        sendGameStart();  // Отправляет начальные данные
        
        while (running) {
            Message message = ProtocolParser.receiveMessage(in);  // Блокирующий вызов, может бросить IOException
            if (message == null) break;  // Разрыв соединения
            handleMessage(message);
        }
    } catch (IOException e) {
        System.err.println("Ошибка в обработчике клиента: " + e.getMessage());
    } finally {
        close();  // Всегда закрываем соединение
    }
}
```

**Особенности:**
- Работает в отдельном потоке
- `receiveMessage()` блокируется до получения сообщения
- При `null` (разрыв соединения) цикл завершается
- `IOException` обрабатывается в try-catch, соединение закрывается в `finally`

##### `sendGameStart()`
**Отправка информации о начале игры:**

```java
String[] data = {
    String.valueOf(playerId),      // 2
    String.valueOf(maze.getSeed()), // seed для синхронизации
    String.valueOf(player.getX()),  // Стартовая X
    String.valueOf(player.getY()),  // Стартовая Y
    String.valueOf(exitX),          // Финиш X
    String.valueOf(exitY)           // Финиш Y
};
Message msg = new Message(MessageType.GAME_START, data);
ProtocolParser.sendMessage(out, msg);
```

**Формат**: `GAME_START|2|seed|startX|startY|exitX|exitY`

##### `handleMessage(Message message)`
**Маршрутизация сообщений:**

```java
switch (message.getType()) {
    case PLAYER_MOVE:
        handlePlayerMove(message);  // Обработка движения
        break;
    case SYNC_REQUEST:
        sendGameStart();            // Повторная отправка начальных данных
        break;
}
```

**Безопасность**: Обрабатывает только известные типы сообщений

##### `handlePlayerMove(Message message)`
**Обработка движения игрока - КРИТИЧЕСКИ ВАЖНЫЙ МЕТОД:**

```java
// 1. Парсинг данных
int pid = Integer.parseInt(data[0]);
String direction = data[1];

// 2. Проверка авторизации
if (pid == playerId) {  // Только свой ID!
    
    // 3. Проверка состояния
    if (player != null && !player.isFinished()) {
        
        // 4. ВАЛИДАЦИЯ НА СЕРВЕРЕ (защита от читов)
        if (gameState.getMaze().canMove(player.getX(), player.getY(), direction)) {
            
            // 5. Вычисление новой позиции
            switch (direction) {
                case "ВВЕРХ": newY--; break;
                case "ВНИЗ": newY++; break;
                case "ВЛЕВО": newX--; break;
                case "ВПРАВО": newX++; break;
            }
            
            // 6. Обновление состояния
            player.setPosition(newX, newY);
            player.setDirection(direction);
            
            // 7. Рассылка обновления
            server.broadcastPosition(pid, newX, newY, direction);
            
            // 8. Проверка победы
            if (gameState.checkWin(pid, newX, newY)) {
                server.broadcastGameEnd(pid, gameState.getElapsedTime());
            }
        }
    }
}
```

**Ключевые моменты:**
- ✅ Проверка авторизации (`pid == playerId`)
- ✅ Валидация движения на сервере (`canMove()`)
- ✅ Сервер - единственный источник истины
- ✅ Рассылка обновлений всем участникам

##### `sendPositionUpdate(int pid, int x, int y, String direction)`
**Отправка обновления позиции:**

```java
String[] data = {
    String.valueOf(pid),
    String.valueOf(x),
    String.valueOf(y),
    direction
};
Message msg = new Message(MessageType.PLAYER_POSITION, data);
sendMessage(msg);
```

**Формат**: `PLAYER_POSITION|playerId|x|y|direction`

##### `sendGameEnd(int winnerId, long time)`
**Отправка окончания игры:**

```java
String[] data = {
    String.valueOf(winnerId),
    String.valueOf(time)
};
Message msg = new Message(MessageType.GAME_END, data);
sendMessage(msg);
```

**Формат**: `GAME_END|winnerId|time`

##### `close()`
**Корректное закрытие соединения:**

```java
running = false;  // Останавливает цикл
in.close();
out.close();
socket.close();
server.removeClient(this);  // Удаляет из списка клиентов
```

**Важно**: Все ресурсы должны быть закрыты

---

### GameClient

**Пакет**: `game.client`  
**Наследует**: `Thread`  
**Назначение**: Клиентское подключение к серверу

#### Основные поля:

```java
private String host;                    // Адрес сервера
private int port;                       // Порт сервера
private Socket socket;                  // Сокет соединения
private PrintWriter out;                // Поток отправки
private BufferedReader in;              // Поток получения
private GameState gameState;            // Локальное состояние игры
private ClientMessageListener listener; // Callback для UI
private boolean running;                // Флаг работы
private int playerId;                   // ID игрока (получается от сервера)
```

#### Интерфейс ClientMessageListener:

```java
public interface ClientMessageListener {
    void onGameStart(int playerId, long mazeSeed, int startX, int startY, int exitX, int exitY);
    void onPositionUpdate(int playerId, int x, int y, String direction);
    void onGameEnd(int winnerId, long time);
}
```

**Назначение**: Уведомляет UI о событиях без прямой зависимости

#### Ключевые методы:

##### `run()`
**Главный цикл клиента:**

```java
try {
    // 1. Подключение
    socket = new Socket(host, port);
    out = new PrintWriter(socket.getOutputStream(), true);
    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    running = true;
    
    // 2. Цикл получения сообщений
    while (running) {
        Message message = ProtocolParser.receiveMessage(in);  // Блокирующий вызов, может бросить IOException
        if (message == null) break;  // Разрыв соединения
        handleMessage(message);
    }
} catch (IOException e) {
    System.err.println("Ошибка в клиенте: " + e.getMessage());
} finally {
    close();  // Всегда закрываем соединение
}
```

**Особенности:**
- Работает в отдельном потоке
- Блокируется на `receiveMessage()` до получения данных
- При разрыве соединения (`null`) цикл завершается
- `IOException` обрабатывается в try-catch, соединение закрывается в `finally`

##### `handleMessage(Message message)`
**Маршрутизация входящих сообщений:**

```java
switch (message.getType()) {
    case GAME_START:
        handleGameStart(message);
        break;
    case PLAYER_POSITION:
        handlePositionUpdate(message);
        break;
    case GAME_END:
        handleGameEnd(message);
        break;
}
```

**Важно**: Клиент только получает сообщения, не обрабатывает логику игры

##### `handleGameStart(Message message)`
**Обработка начала игры - КРИТИЧЕСКИ ВАЖНО:**

```java
// 1. Парсинг данных
int pid = Integer.parseInt(data[0]);      // playerId
long seed = Long.parseLong(data[1]);     // seed для лабиринта
int startX = Integer.parseInt(data[2]);
int startY = Integer.parseInt(data[3]);
int exitX = Integer.parseInt(data[4]);
int exitY = Integer.parseInt(data[5]);

// 2. Создание лабиринта с ТЕМ ЖЕ SEED
Maze maze = new Maze(Constants.MAZE_WIDTH, Constants.MAZE_HEIGHT, seed);

// 3. Инициализация состояния
gameState.initialize(maze, exitX, exitY);
Player player = new Player(pid, startX, startY);
gameState.addPlayer(player);

// 4. Уведомление UI
listener.onGameStart(pid, seed, startX, startY, exitX, exitY);
```

**Ключевой момент**: Использование того же `seed` гарантирует идентичный лабиринт!

##### `handlePositionUpdate(Message message)`
**Обработка обновления позиции:**

```java
// 1. Парсинг
int pid = Integer.parseInt(data[0]);
int x = Integer.parseInt(data[1]);
int y = Integer.parseInt(data[2]);
String direction = data[3];

// 2. Обновление локального состояния
player.setPosition(x, y);
player.setDirection(direction);

// 3. Уведомление UI
listener.onPositionUpdate(pid, x, y, direction);
```

**Важно**: Клиент обновляет состояние, но не валидирует его (валидация на сервере)

##### `handleGameEnd(Message message)`
**Обработка окончания игры:**

```java
int winnerId = Integer.parseInt(data[0]);
long time = Long.parseLong(data[1]);
listener.onGameEnd(winnerId, time);
```

##### `sendMove(String direction)`
**Отправка запроса на движение:**

```java
String[] data = {
    String.valueOf(playerId),
    direction
};
Message msg = new Message(MessageType.PLAYER_MOVE, data);
ProtocolParser.sendMessage(out, msg);
```

**Формат**: `PLAYER_MOVE|playerId|direction`

**Важно**: Это запрос, а не команда. Сервер решает, можно ли двигаться

##### `requestSync()`
**Запрос синхронизации состояния:**

```java
String[] data = {String.valueOf(playerId)};
Message msg = new Message(MessageType.SYNC_REQUEST, data);
ProtocolParser.sendMessage(out, msg);
```

**Назначение**: Если клиент потерял состояние, может запросить повторную отправку `GAME_START`

---

## Протокол

### MessageType

**Пакет**: `game.protocol`  
**Тип**: `enum`  
**Назначение**: Определяет типы сообщений протокола

#### Значения:

```java
PLAYER_POSITION,  // Обновление позиции игрока
GAME_START,       // Начало игры
GAME_END,         // Окончание игры
PLAYER_MOVE,      // Запрос на движение
SYNC_REQUEST      // Запрос синхронизации
```

**Использование**: В `switch` для маршрутизации сообщений

---

### Message

**Пакет**: `game.protocol`  
**Назначение**: Объект сообщения протокола

#### Структура:

```java
private MessageType type;  // Тип сообщения
private String[] data;     // Данные сообщения
```

#### Ключевые методы:

##### `toProtocolString()`
**Преобразование в строку для отправки:**

```java
public String toProtocolString() {
    StringBuilder sb = new StringBuilder();
    sb.append(type.name());  // "GAME_START"
    
    if (data != null) {
        for (String item : data) {
            sb.append("|").append(item);  // "|2|seed|x|y"
        }
    }
    
    sb.append("\n");  // Конец строки
    return sb.toString();
}
```

**Пример результата**: `"GAME_START|2|1234567890|39|49|20|25\n"`

##### `fromProtocolString(String line)`
**Парсинг строки в объект Message:**

```java
// 1. Проверка на null/пустую строку
if (line == null || line.trim().isEmpty()) {
    return null;
}

// 2. Разделение по разделителю
String[] parts = line.trim().split("\\|");
// parts = ["GAME_START", "2", "1234567890", "39", "49", "20", "25"]

if (parts.length == 0) {
    return null;
}

// 3. Парсинг типа (может бросить IllegalArgumentException)
try {
    MessageType type = MessageType.valueOf(parts[0]);
    
    // 4. Остальные - данные
    String[] data = new String[parts.length - 1];
    System.arraycopy(parts, 1, data, 0, data.length);
    
    // 5. Создание объекта
    return new Message(type, data);
} catch (IllegalArgumentException e) {
    return null;  // Неверный тип сообщения
}
```

**Обработка ошибок**: 
- При неверном формате возвращает `null`
- При неверном типе сообщения (`IllegalArgumentException`) возвращает `null`

---

### ProtocolParser

**Пакет**: `game.protocol`  
**Назначение**: Утилитный класс для работы с протоколом

#### Методы:

##### `sendMessage(PrintWriter out, Message message)`
**Отправка сообщения:**

```java
if (out != null && message != null) {
    out.print(message.toProtocolString());  // Отправка строки
    out.flush();  // Принудительный сброс буфера
}
```

**Особенность**: Использует `PrintWriter` с автоматическим flush

##### `receiveMessage(BufferedReader in)`
**Получение сообщения:**

```java
String line = in.readLine();  // Блокирующий вызов, читает до \n
if (line == null) {
    return null;  // Разрыв соединения
}
return Message.fromProtocolString(line);
```

**Важно**: 
- `readLine()` блокируется до получения полной строки
- Метод бросает `IOException`, который обрабатывается в вызывающем коде
- При разрыве соединения возвращает `null`

#### Формат протокола:

```
ТИП|данные1|данные2|данные3\n
```

**Примеры:**
- `GAME_START|2|1234567890|39|49|20|25\n`
- `PLAYER_MOVE|2|ВПРАВО\n`
- `PLAYER_POSITION|1|5|10|ВНИЗ\n`
- `GAME_END|1|15000\n`
- `SYNC_REQUEST|2\n`

---

## Модель данных

### GameState

**Пакет**: `game.model`  
**Назначение**: Хранит состояние игры

#### Основные поля:

```java
private Maze maze;                    // Лабиринт
private Map<Integer, Player> players;  // Игроки (ID -> Player)
private int exitX, exitY;             // Позиция финиша
private boolean gameStarted;          // Флаг начала игры
private boolean gameEnded;            // Флаг окончания игры
private long startTime;               // Время начала игры
private int winnerId;                 // ID победителя
```

#### Ключевые методы:

##### `initialize(Maze maze, int exitX, int exitY)`
**Инициализация игры:**

```java
this.maze = maze;
this.exitX = exitX;
this.exitY = exitY;
this.gameStarted = true;
this.startTime = System.currentTimeMillis();  // Засекаем время
```

##### `checkWin(int playerId, int x, int y)`
**Проверка победы:**

```java
if (x == exitX && y == exitY) {  // Игрок на финише?
    if (!gameEnded) {  // Игра еще не закончена?
        endGame(playerId);  // Помечаем игру как завершенную
        player.finish(getElapsedTime());  // Записываем время финиша
    }
    return true;
}
return false;
```

**Защита**: Проверка `!gameEnded` предотвращает повторное завершение

##### `getElapsedTime()`
**Вычисление прошедшего времени:**

```java
if (gameStarted) {
    return System.currentTimeMillis() - startTime;
}
return 0;
```

---

### Player

**Пакет**: `game.model`  
**Назначение**: Модель игрока

#### Поля:

```java
private int id;              // Уникальный ID игрока
private int x, y;            // Позиция на карте
private String direction;    // Направление ("ВВЕРХ", "ВНИЗ", "ВЛЕВО", "ВПРАВО")
private boolean finished;    // Флаг финиширования
private long finishTime;     // Время финиша (мс)
```

#### Методы:

- **Геттеры**: `getId()`, `getX()`, `getY()`, `getDirection()`, `isFinished()`, `getFinishTime()`
- **Сеттеры**: `setPosition(x, y)`, `setDirection(direction)`
- **finish(time)**: Помечает игрока как финишировавшего

**Простота**: Класс только хранит данные, логика в `GameState`

---

### Maze

**Пакет**: `game.model`  
**Назначение**: Представляет лабиринт и проверяет движение

#### Внутренняя структура:

```java
private boolean[][] walls;  // true = стена, false = проход
// Размер: [height * 2 + 1][width * 2 + 1]
// Координаты игрока (x, y) → координаты лабиринта (x*2+1, y*2+1)
```

**Почему `* 2 + 1`?** Внутренний формат хранит стены между клетками

#### Ключевые методы:

##### `Maze(int width, int height, long seed)`
**Конструктор с seed:**

```java
this.seed = seed;
this.walls = new boolean[height * 2 + 1][width * 2 + 1];
generate();  // Генерирует лабиринт
```

**Важно**: Seed используется для выбора генератора

##### `generate()`
**Процесс генерации:**

```java
// 1. Выбор генератора на основе seed
MazeGenerator generator = MazeGeneratorFactory.createGenerator(seed);

// 2. Генерация лабиринта
boolean[][] gameCells = generator.generate(width, height);

// 3. Гарантия проходимости стартовых позиций
gameCells[0][0] = false;  // Игрок 1
gameCells[height-1][width-1] = false;  // Игрок 2

// 4. Конвертация в внутренний формат
convertToInternalFormat(gameCells);
```

##### `isWall(int x, int y)`
**Проверка наличия стены:**

```java
// 1. Проверка границ
if (x < 0 || x >= width || y < 0 || y >= height) {
    return true;  // Вне границ = стена
}

// 2. Конвертация координат
int mazeX = x * 2 + 1;
int mazeY = y * 2 + 1;

// 3. Проверка в массиве
return walls[mazeY][mazeX];
```

##### `canMove(int x, int y, String direction)`
**Проверка возможности движения:**

```java
// 1. Вычисление новой позиции
int newX = x, newY = y;
switch (direction) {
    case "ВВЕРХ": newY--; break;
    case "ВНИЗ": newY++; break;
    case "ВЛЕВО": newX--; break;
    case "ВПРАВО": newX++; break;
}

// 2. Проверка границ
if (newX < 0 || newX >= width || newY < 0 || newY >= height) {
    return false;
}

// 3. Проверка стены
return !isWall(newX, newY);
```

**Использование**: Вызывается на сервере для валидации движения

##### `convertToInternalFormat(boolean[][] gameCells)`
**Конвертация в внутренний формат:**

```java
// 1. Инициализация: все стены
for (int i = 0; i < walls.length; i++) {
    for (int j = 0; j < walls[i].length; j++) {
        walls[i][j] = true;
    }
}

// 2. Заполнение проходов
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        if (!gameCells[y][x]) {  // Если проход
            int mazeX = x * 2 + 1;
            int mazeY = y * 2 + 1;
            walls[mazeY][mazeX] = false;
            
            // Создаем проходы к соседям
            if (y > 0 && !gameCells[y-1][x]) {
                walls[mazeY-1][mazeX] = false;  // Вверх
            }
            // ... аналогично для других направлений
        }
    }
}
```

---

## Генерация лабиринта

### MazeGenerator (Интерфейс)

**Пакет**: `game.model`  
**Назначение**: Интерфейс для генераторов лабиринта

#### Методы:

```java
boolean[][] generate(int width, int height);  // Генерирует лабиринт
String getName();                              // Возвращает название
```

**Реализации**: `GridMazeGenerator`, `OpenMazeGenerator`, `PathMazeGenerator`

---

### MazeGeneratorFactory

**Пакет**: `game.model`  
**Назначение**: Фабрика для создания генераторов

#### Методы:

##### `createGenerator(long seed)`
**Создание генератора на основе seed:**

```java
Random random = new Random(seed);  // Детерминированный Random
int choice = random.nextInt(3);    // 0, 1 или 2

switch (choice) {
    case 0: return new GridMazeGenerator();   // Сетка
    case 1: return new OpenMazeGenerator();   // Открытый
    case 2: return new PathMazeGenerator();   // Пути
}
```

**Ключевой момент**: Одинаковый seed → одинаковый Random → одинаковый выбор → одинаковый генератор

##### `createGenerator(int index)`
**Создание генератора по индексу (для тестирования)**

##### `createRandomGenerator()`
**Создание случайного генератора (использует текущее время как seed)**

---

### GridMazeGenerator

**Пакет**: `game.model`  
**Реализует**: `MazeGenerator`  
**Алгоритм**: Создает регулярную сетку проходов

#### Логика генерации:

```java
// 1. Все клетки = стены
for (int i = 0; i < height; i++) {
    for (int j = 0; j < width; j++) {
        gameCells[i][j] = true;
    }
}

// 2. Первая строка полностью проходима
for (int x = 0; x < width; x++) {
    gameCells[0][x] = false;
}

// 3. Последний столбец полностью проходим
for (int y = 0; y < height; y++) {
    gameCells[y][width-1] = false;
}

// 4. Вертикальные проходы через каждые 8 столбцов
for (int col = 8; col < width; col += 8) {
    for (int y = 0; y < height; y++) {
        gameCells[y][col] = false;
    }
}

// 5. Горизонтальные проходы через каждые 8 строк
for (int row = 8; row < height; row += 8) {
    for (int x = 0; x < width; x++) {
        gameCells[row][x] = false;
    }
}
```

**Результат**: Структурированная сетка с множеством маршрутов

---

### OpenMazeGenerator

**Пакет**: `game.model`  
**Реализует**: `MazeGenerator`  
**Алгоритм**: Создает открытое поле с минимумом стен

#### Логика генерации:

```java
// 1. Каждая четная строка - проход
for (int y = 0; y < height; y++) {
    if (y % 2 == 0) {
        for (int x = 0; x < width; x++) {
            gameCells[y][x] = false;
        }
    }
}

// 2. Каждый четный столбец - проход
for (int x = 0; x < width; x++) {
    if (x % 2 == 0) {
        for (int y = 0; y < height; y++) {
            gameCells[y][x] = false;
        }
    }
}

// 3. Дополнительные проходы через каждые 4 строки/столбца
for (int row = 3; row < height; row += 4) {
    // Горизонтальные проходы
}
for (int col = 3; col < width; col += 4) {
    // Вертикальные проходы
}
```

**Результат**: Открытое поле, легко перемещаться

---

### PathMazeGenerator

**Пакет**: `game.model`  
**Реализует**: `MazeGenerator`  
**Алгоритм**: Создает основные пути с ответвлениями

#### Логика генерации:

```java
// 1. Основной путь от старта 1 (0,0) к центру
for (int x = 0; x < width / 2; x++) {
    gameCells[0][x] = false;  // Горизонтально вправо
}
for (int y = 0; y < height / 2; y++) {
    gameCells[y][width/2] = false;  // Вертикально вниз
}

// 2. Основной путь от старта 2 (width-1, height-1) к центру
for (int x = width / 2; x < width; x++) {
    gameCells[height-1][x] = false;  // Горизонтально влево
}
for (int y = height / 2; y < height; y++) {
    gameCells[y][width/2] = false;  // Вертикально вверх
}

// 3. Центральные пути (горизонтальный и вертикальный)
int centerY = height / 2;
int centerX = width / 2;
// ... создание центральных путей

// 4. Боковые ответвления
// ... создание дополнительных путей

// 5. Диагональные проходы в углах
// ... для лучшей связности
```

**Результат**: Несколько основных маршрутов с боковыми ответвлениями

---

## UI компоненты

### GameWindow

**Пакет**: `game.ui`  
**Наследует**: `JFrame`  
**Назначение**: Главное окно приложения

#### Основные функции:

- Создает и размещает панели (GamePanel, CompassPanel, InfoPanel)
- Обрабатывает клавиатуру (стрелки/WASD)
- Управляет сетью (запуск сервера/подключение клиента)
- Синхронизирует состояние между панелями

#### Сетевые аспекты:

##### `setupNetwork()`
**Инициализация сети:**

```java
if (isServer) {
    try {
        // Создает GameServer
        server = new GameServer(Constants.DEFAULT_PORT);
        server.addServerPlayer();
        
        // Устанавливает listener для уведомлений
        server.setGameEndListener((winnerId, time) -> {
            SwingUtilities.invokeLater(() -> {
                onGameEnd(winnerId, time);
            });
        });
        
        // Запускает сервер в отдельном потоке
        new Thread(() -> server.start()).start();
        
        // Ожидание инициализации игры через polling
        new Thread(() -> {
            while (server != null && !gameStarted) {
                try {
                    Thread.sleep(500);  // Проверяем каждые 500мс
                    GameState serverState = server.getGameState();
                    if (serverState != null && serverState.isGameStarted()) {
                        SwingUtilities.invokeLater(() -> {
                            initializeServerGameState(serverState);
                        });
                        break;
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
        }).start();
    } catch (IOException e) {
        // Обработка ошибки запуска сервера
    }
} else {
    // Создает GameClient
    String host = JOptionPane.showInputDialog(this, "Введите адрес сервера:", "localhost");
    if (host == null || host.trim().isEmpty()) {
        host = "localhost";
    }
    
    client = new GameClient(host, Constants.DEFAULT_PORT, this);
    client.start();
    infoPanel.setConnectionStatus(true);
}
```

**Особенности серверного режима:**
- Использует polling для ожидания инициализации игры (каждые 500мс)
- Это необходимо, так как `GameServer.start()` работает асинхронно
- После инициализации вызывает `initializeServerGameState()` для синхронизации UI

##### `handleServerMove(String direction)`
**Обработка движения серверного игрока:**

```java
// 1. Проверка возможности движения
if (maze.canMove(player.getX(), player.getY(), direction)) {
    // 2. Обновление позиции
    player.setPosition(newX, newY);
    
    // 3. Рассылка обновления
    server.broadcastPosition(playerId, newX, newY, direction);
    
    // 4. Проверка победы
    if (gameState.checkWin(playerId, newX, newY)) {
        server.broadcastGameEnd(playerId, gameState.getElapsedTime());
    }
}
```

##### Реализация `ClientMessageListener`:

```java
@Override
public void onGameStart(int pid, long mazeSeed, int startX, int startY, int exitX, int exitY) {
    SwingUtilities.invokeLater(() -> {
        // Создает лабиринт с seed от сервера
        Maze maze = new Maze(Constants.MAZE_WIDTH, Constants.MAZE_HEIGHT, mazeSeed);
        gameState.initialize(maze, exitX, exitY);
        // Обновляет UI
    });
}

@Override
public void onPositionUpdate(int pid, int x, int y, String direction) {
    SwingUtilities.invokeLater(() -> {
        // Обновляет позицию игрока
        player.setPosition(x, y);
        player.setDirection(direction);
        // Перерисовывает панели
    });
}

@Override
public void onGameEnd(int winnerId, long time) {
    SwingUtilities.invokeLater(() -> {
        // Показывает победителя
        handleGameEnd(winnerId, time);
    });
}
```

**Важно**: Все обновления UI через `SwingUtilities.invokeLater()` для потокобезопасности

---

### GamePanel

**Пакет**: `game.ui`  
**Наследует**: `JPanel`  
**Назначение**: Отрисовка игрового поля

#### Основные функции:

- Рисует лабиринт (стены и проходы)
- Рисует игрока с направлением
- Рисует выход с пульсирующим эффектом
- Ограниченная видимость (5 клеток вокруг игрока)
- Центрирование камеры на игроке

#### Сетевые аспекты:

- Получает `GameState` от `GameWindow`
- Обновляется через `repaint()` при получении обновлений от сервера
- Не взаимодействует с сетью напрямую

---

### CompassPanel

**Пакет**: `game.ui`  
**Наследует**: `JPanel`  
**Назначение**: Компас, показывающий направление к выходу

#### Основные функции:

- Вычисляет угол к выходу
- Плавно поворачивает стрелку
- Анимация через Timer (60 FPS)

#### Сетевые аспекты:

- Использует `GameState` для вычисления направления
- Обновляется при получении обновлений позиции

---

### InfoPanel

**Пакет**: `game.ui`  
**Наследует**: `JPanel`  
**Назначение**: Информационная панель

#### Компоненты:

- `timeLabel` - таймер игры
- `statusLabel` - статус игры
- `connectionLabel` - статус подключения

#### Сетевые аспекты:

- Показывает статус подключения
- Обновляется при событиях игры (начало, конец)

---

## Утилиты

### Constants

**Пакет**: `game.utils`  
**Назначение**: Хранит константы проекта

#### Константы:

```java
MAZE_WIDTH = 40;              // Ширина лабиринта
MAZE_HEIGHT = 50;             // Высота лабиринта
CELL_SIZE = 30;               // Размер клетки в пикселях
VISIBILITY_RADIUS = 5;        // Радиус видимости
DEFAULT_PORT = 12345;         // Порт сервера
WINDOW_WIDTH = 1000;          // Ширина окна
WINDOW_HEIGHT = 700;          // Высота окна
// ... размеры панелей
```

---

### Main

**Пакет**: `game`  
**Назначение**: Точка входа в приложение

#### Функции:

- Устанавливает Look and Feel
- Спрашивает пользователя (Сервер/Клиент)
- Создает `GameWindow`

---

## Потоки данных

### Инициализация игры

```
1. GameWindow.setupNetwork()
   ↓
2. GameServer.start()
   ├─ waitForServerPlayer()
   ├─ waitForClient() → serverSocket.accept()
   └─ initializeGame()
       ├─ Создает Maze с seed
       ├─ Устанавливает позиции игроков
       └─ client.sendGameStart()
           ↓
3. ClientHandler.sendGameStart()
   ├─ Создает Message(GAME_START, data)
   └─ ProtocolParser.sendMessage()
       ↓
4. GameClient.receiveMessage()
   ├─ ProtocolParser.receiveMessage()
   ├─ handleGameStart()
   │   ├─ Создает Maze с тем же seed
   │   └─ listener.onGameStart()
   └─ GameWindow.onGameStart()
       ├─ Инициализирует GameState
       └─ Обновляет UI панели
```

### Движение игрока

```
1. Игрок нажимает клавишу
   ↓
2. GameWindow.handleMove()
   ├─ Если сервер: handleServerMove()
   │   ├─ Проверяет canMove()
   │   ├─ Обновляет позицию
   │   └─ server.broadcastPosition()
   │
   └─ Если клиент: client.sendMove()
       ↓
3. GameClient.sendMove()
   ├─ Создает Message(PLAYER_MOVE, data)
   └─ ProtocolParser.sendMessage()
       ↓
4. ClientHandler.receiveMessage()
   ├─ handlePlayerMove()
   │   ├─ Проверяет авторизацию (pid == playerId)
   │   ├─ Валидирует движение (canMove())
   │   ├─ Обновляет GameState
   │   └─ server.broadcastPosition()
   │       ↓
5. GameServer.broadcastPosition()
   ├─ Обновляет GameState на сервере
   └─ client.sendPositionUpdate()
       ↓
6. GameClient.receiveMessage()
   ├─ handlePositionUpdate()
   └─ listener.onPositionUpdate()
       ↓
7. GameWindow.onPositionUpdate()
   ├─ Обновляет GameState
   └─ repaint() панелей
```

### Окончание игры

```
1. checkWin() возвращает true
   ↓
2. GameServer.broadcastGameEnd()
   ├─ gameEndListener.onGameEnd() → GameWindow
   └─ client.sendGameEnd()
       ↓
3. GameClient.receiveMessage()
   ├─ handleGameEnd()
   └─ listener.onGameEnd()
       ↓
4. GameWindow.onGameEnd()
   └─ handleGameEnd()
       ├─ Показывает победителя
       └─ Останавливает таймер
```

---

## Безопасность и валидация

### 1. Авторизация

```java
// ClientHandler.handlePlayerMove()
if (pid == playerId) {  // Только свой ID!
    // Обработка
}
```

**Защита**: Клиент не может двигать другого игрока

### 2. Валидация на сервере

```java
// Все движения проверяются на сервере
if (gameState.getMaze().canMove(player.getX(), player.getY(), direction)) {
    // Разрешено
}
```

**Защита**: Клиент не может "читерить" - сервер проверяет все движения

### 3. Единый источник истины

- `GameState` на сервере - это источник истины
- Клиент получает обновления, но не управляет логикой
- Все изменения проходят через сервер

### 4. Синхронизация лабиринта

**Процесс синхронизации:**

1. **Сервер генерирует seed:**
   ```java
   long seed = System.currentTimeMillis();
   Maze maze = new Maze(width, height, seed);
   ```

2. **Сервер отправляет seed клиенту:**
   ```java
   // В GAME_START сообщении
   String[] data = {
       String.valueOf(playerId),
       String.valueOf(maze.getSeed()),  // ← seed передается клиенту
       // ... остальные данные
   };
   ```

3. **Клиент создает лабиринт с тем же seed:**
   ```java
   long seed = Long.parseLong(data[1]);  // Получаем seed от сервера
   Maze maze = new Maze(Constants.MAZE_WIDTH, Constants.MAZE_HEIGHT, seed);
   ```

4. **MazeGeneratorFactory использует seed для выбора генератора:**
   ```java
   Random random = new Random(seed);  // Детерминированный Random
   int choice = random.nextInt(3);    // Одинаковый seed → одинаковый choice
   ```

**Результат:**
- Одинаковый `seed` → одинаковый `Random` → одинаковый выбор генератора → одинаковый лабиринт
- Гарантирует идентичность на сервере и клиенте
- Клиент не может "подглядеть" лабиринт заранее, так как seed генерируется сервером

---

## Обработка ошибок

### Сетевые ошибки

```java
try {
    // Сетевые операции
} catch (IOException e) {
    System.err.println("Ошибка: " + e.getMessage());
    // Закрытие соединений
}
```

### Парсинг сообщений

```java
try {
    int pid = Integer.parseInt(data[0]);
} catch (NumberFormatException e) {
    System.err.println("Неверные данные");
    return;  // Игнорируем неверное сообщение
}
```

### Разрыв соединения

```java
Message message = ProtocolParser.receiveMessage(in);
if (message == null) {
    break;  // Разрыв соединения, выходим из цикла
}
```

---

## Заключение

Архитектура проекта построена на принципах:

1. **Client-Server**: Сервер - авторитетный источник, клиент - отправитель команд
2. **Простой протокол**: Текстовый формат с разделителем `|`
3. **Валидация на сервере**: Все движения проверяются сервером
4. **Синхронизация через seed**: Одинаковый лабиринт на сервере и клиенте
5. **Потокобезопасность**: UI обновляется через EDT
6. **Разделение ответственности**: Каждый класс имеет четкую роль

Сетевое взаимодействие является основой игры, обеспечивая синхронизацию состояния между участниками и защиту от читерства.

